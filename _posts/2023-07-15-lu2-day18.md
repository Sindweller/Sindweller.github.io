---
layout: default
title: 2023/07/15 代码随想录2Day18【二叉树5】
author: sindweller <sindweller5530@gmail.com>
tags: [代码随想录二刷]
---


## 找树左下角的值

层序遍历然后每次将left更新为最左边的值。

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func findBottomLeftValue(root *TreeNode) int {
    var q []*TreeNode
    left := root
    q = append(q, root)
    for len(q) > 0{
        left = q[0] // 记录最左
        size := len(q)
        for size > 0{
            cur := q[0]
            q = q[1:]
            if cur.Left != nil{
                q = append(q, cur.Left)
            }
            if cur.Right != nil{
                q = append(q, cur.Right)
            }
            size --
        }
    }
    return left.Val
}
```

## 路径总和

回溯dfs

不需要遍历整棵树，因此返回值是bool类型

计数器count每次减去当前值，然后到0就是ok

如果到了叶子节点，且count还不为0（无论是正负）都返回false

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func hasPathSum(root *TreeNode, targetSum int) bool {
    if root == nil{
        return false
    }
    targetSum -= root.Val
    if root.Left == nil&& root.Right == nil{
        return targetSum == 0 // 返回是否可以
    }

    return hasPathSum(root.Left,targetSum)||hasPathSum(root.Right,targetSum)
}
```

## 从中序与后序遍历序列构造二叉树

每次选取后序的最后一个元素为根，然后按照中序切割，左｜根｜右，然后递归处理

此时再去后序切割左｜右｜根

这种切割时保持左闭右开

后续数组是按照数组长度来切分的

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

var (
    hash map[int]int
)
func buildTree(inorder []int, postorder []int) *TreeNode {
    hash = make(map[int]int)
    for i, v := range inorder {  // 用map保存中序序列的数值对应位置
        hash[v] = i
    }
    // 以左闭右闭的原则进行切分
    // rootindex根节点的下标是后序遍历的最末尾，中序数组是从最左0开始，到末尾结束
    root := rebuild(inorder, postorder, len(postorder)-1, 0, len(inorder)-1)
    return root
}
// rootIdx表示根节点在后序数组中的索引，l, r 表示在中序数组中的前后切分点
func rebuild(inorder []int, postorder []int, rootIdx int, l, r int) *TreeNode {
    if l > r {    // 说明没有元素，返回空树
        return nil
    }
    if l == r {  // 只剩唯一一个元素，直接返回
        return &TreeNode{Val : inorder[l]}
    }
    rootV := postorder[rootIdx]  // 根据后序数组找到根节点的值
    rootIn := hash[rootV]        // 根据根节点的值找到根节点在对应的中序数组中的位置
    root := &TreeNode{Val : rootV}   // 构造根节点
    // 重建左节点和右节点
    // 左｜根｜右
    // 左子树是从l到inorder位置-1 左边新的根节点要再后序数组中排除右边 左|右｜rootindex，所以是rootIdx-（右子树）-1
    // 右子树就是从r（最右侧）减去rootIn的位置，有这么多个节点是位于右子树中的
    root.Left = rebuild(inorder, postorder, rootIdx-(r-rootIn)-1, l, rootIn-1)
    root.Right = rebuild(inorder, postorder, rootIdx-1, rootIn+1, r)
    return root
}
```